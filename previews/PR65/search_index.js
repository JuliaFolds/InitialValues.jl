var documenterSearchIndex = {"docs":
[{"location":"#InitialValues.jl","page":"Home","title":"InitialValues.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"InitialValues\nInitialValues.InitialValue\nInitialValues.INIT\nInitialValues.@def\nInitialValues.@def_monoid\nInitialValues.@disambiguate\nInitialValues.hasinitialvalue\nInitialValues.isknown\nInitialValues.asmonoid","category":"page"},{"location":"#InitialValues","page":"Home","title":"InitialValues","text":"InitialValues.jl: Canonical default initial values and identity elements for Julia\n\n(Image: Stable) (Image: Dev) (Image: GitHub Actions) (Image: Codecov) (Image: Coveralls) (Image: Aqua QA)\n\nInitialValues.jl provides a generic singleton initial value InitialValue(f) that can be used as a₀ in f(a₀, x).  For a binary operator op, it means that InitialValue(op) acts like the identity for any type of x:\n\njulia> using InitialValues\n\njulia> InitialValue(+) + 1\n1\n\njulia> 1.0 + InitialValue(+)\n1.0\n\njulia> foldl(+, 1:3, init=InitialValue(+))\n6\n\nFollowing methods are defined for the binary operators in Base:\n\njulia> InitialValue(*) * 1\n1\n\njulia> InitialValue(&) & 1\n1\n\njulia> InitialValue(|) | 1\n1\n\njulia> min(InitialValue(min), 1)\n1\n\njulia> max(InitialValue(max), 1)\n1\n\njulia> Base.add_sum(InitialValue(Base.add_sum), 1)\n1\n\njulia> Base.mul_prod(InitialValue(Base.mul_prod), 1)\n1\n\nInitialValue is not called Identity because it is useful to define it for functions that are not binary operator (symmetric in signature).  For example, push!! in BangBang.jl defines\n\njulia> using BangBang\n\njulia> push!!(InitialValue(push!!), 1)\n1-element Array{Int64,1}:\n 1\n\nThis provides a powerful pattern when combined with foldl:\n\njulia> foldl(push!!, (1, missing, 2.0), init=InitialValue(push!!))\n3-element Array{Union{Missing, Float64},1}:\n 1.0\n  missing\n 2.0\n\nTransducers.jl extensively uses InitialValue.\n\nAs binary operators like * in Base are heavily overloaded, creating generic definitions such as above could have introduced method ambiguities.  To protect against such situation, InitialValues.jl is tested using Aqua.jl.\n\n\n\n\n\n","category":"module"},{"location":"#InitialValues.InitialValue","page":"Home","title":"InitialValues.InitialValue","text":"InitialValue(OP)\n\nCreate a generic (left) identity for a binary operator op.  For general binary function, it provides an identity-like generic default value (see BangBang.push!!).\n\nExamples\n\njulia> using InitialValues\n\njulia> InitialValue(*) isa InitialValues.InitialValue\ntrue\n\njulia> InitialValue(*) * 1\n1\n\njulia> InitialValue(*) * missing\nmissing\n\njulia> InitialValue(*) * \"right\"\n\"right\"\n\njulia> InitialValue(*) * :actual_anything_works\n:actual_anything_works\n\njulia> foldl(+, 1:3, init=InitialValue(+))\n6\n\njulia> float(InitialValue(*))\n1.0\n\njulia> Integer(InitialValue(+))\n0\n\n\n\n\n\n","category":"type"},{"location":"#InitialValues.INIT","page":"Home","title":"InitialValues.INIT","text":"INIT :: InitialValue\n\nA generic initial value.  Unlike InitialValue, this does not detect an error when INIT is used with unintended operations.\n\nExamples\n\njulia> using InitialValues\n\njulia> InitialValue(+) * 0  # `InitialValue(op)` must be used with `op`\nERROR: MethodError: no method matching *(::InitialValues.InitialValueOf{typeof(+)}, ::Int64)\n[...]\n\njulia> INIT * 123\n123\n\njulia> foldl(+, 1:3, init=INIT)\n6\n\n\n\n\n\n","category":"constant"},{"location":"#InitialValues.@def","page":"Home","title":"InitialValues.@def","text":"InitialValues.@def op [y = :x]\n\nDefine a generic (left) identity for a binary operator op.  Specify the second argument for a binary function in general.\n\nInitialValues.@def op is expanded to\n\nop(::GenericInitialValue{typeof(op)}, x) = x\nInitialValues.hasinitialvalue(::Type{typeof(op)}) = true\n\nFor operations like push!, it is useful to define the returned value to be different from x.  This can be done by using the second argument to the maco; i.e., InitialValues.@def push! [x] is expanded to\n\npush!(::GenericInitialValue{typeof(push!)}, x) = [x]\nInitialValues.hasinitialvalue(::Type{typeof(push!)}) = true\n\nNote that the second argument to op is always x.\n\n\n\n\n\n","category":"macro"},{"location":"#InitialValues.@def_monoid","page":"Home","title":"InitialValues.@def_monoid","text":"InitialValues.@def_monoid op\n\nDefine a generic identity for a binary operator op. InitialValues.@def_monoid op is expanded to\n\nop(::GenericInitialValue{typeof(op)}, x::GenericInitialValue{typeof(op)}) = x\nop(x, ::GenericInitialValue{typeof(op)}) = x\nop(::GenericInitialValue{typeof(op)}, x) = x\nInitialValues.hasinitialvalue(::Type{typeof(op)}) = true\n\n\n\n\n\n","category":"macro"},{"location":"#InitialValues.@disambiguate","page":"Home","title":"InitialValues.@disambiguate","text":"InitialValues.@disambiguate op OtherType\n\nDisambiguate the method introduced by @def_monoid.\n\nIt is expanded to\n\nop(::GenericInitialValue{typeof(op)}, x::OtherType) = x\nop(x::OtherType, ::GenericInitialValue{typeof(op)}) = x\n\n\n\n\n\n","category":"macro"},{"location":"#InitialValues.hasinitialvalue","page":"Home","title":"InitialValues.hasinitialvalue","text":"InitialValues.hasinitialvalue(op) :: Bool\n\nExamples\n\njulia> using InitialValues\n\njulia> all(InitialValues.hasinitialvalue, [\n           *,\n           +,\n           &,\n           |,\n           min,\n           max,\n           Base.add_sum,\n           Base.mul_prod,\n       ])\ntrue\n\njulia> InitialValues.hasinitialvalue((x, y) -> x + y)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#InitialValues.isknown","page":"Home","title":"InitialValues.isknown","text":"InitialValues.isknown(::InitialValue) :: Bool\n\nExamples\n\njulia> using InitialValues\n\njulia> InitialValues.isknown(InitialValue(+))\ntrue\n\njulia> InitialValues.isknown(InitialValue((x, y) -> x + y))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#InitialValues.asmonoid","page":"Home","title":"InitialValues.asmonoid","text":"asmonoid(op) -> op′\n\n\"Add\" (adjoin) an identity element to the semigroup op if necessary and return the monoid op′.\n\nExamples\n\njulia> using InitialValues\n\njulia> asmonoid(*) === *  # do nothing if `InitialValue` is already defined\ntrue\n\njulia> append!′ = asmonoid(append!);\n\njulia> xs = [];\n\njulia> append!′(InitialValue(append!′), xs) === xs\ntrue\n\njulia> foldl(append!′, [xs, [1], [2, 3]], init=InitialValue(append!′))\n3-element Array{Any,1}:\n 1\n 2\n 3\n\njulia> ans === xs  # `xs` is modified\ntrue\n\n\n\n\n\n","category":"function"}]
}
